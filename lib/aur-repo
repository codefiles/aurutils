#!/bin/bash
# aur-repo - manage local repositories
[[ -v AUR_DEBUG ]] && set -o xtrace
argv0=repo
PS4='+(${BASH_SOURCE}:${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'

# default options
db_query=local mode=none attr=none list_cols=1,2

usage() {
    printf >&2 'usage: %s [-d repo] [-r path] [-alqtuS]\n' "$argv0"
    exit 1
}

source /usr/share/makepkg/util/parseopts.sh

## option parsing
opt_short='c:d:f:r:F:alqtuJS'
opt_long=('config:' 'database:' 'root:' 'all' 'list' 'list-repo' 'list-attr' 'path'
          'list-path' 'sync' 'upgrades' 'quiet' 'attr:' 'table' 'json' 'format:')
opt_hidden=('dump-options' 'repo:' 'repo-list' 'path-list' 'status'
            'status-file' 'field:')

if ! parseopts "$opt_short" "${opt_long[@]}" "${opt_hidden[@]}" -- "$@"; then
    usage
fi
set -- "${OPTRET[@]}"

unset mode conf_args db_name db_root vercmp_args attr format_str status_file
while true; do
    case $1 in
        -d|--database|--repo)
            shift; db_name=$1 ;;
        -r|--root)
            shift; db_root=$1 ;;
        -c|--config)
            shift; conf_args+=(--config "$1") ;;
        -q|--quiet)
            list_cols=1; vercmp_args+=(-q) ;;
        -S|--sync)
            db_query=sync ;;
        -a|--all)
            mode=upgrades; vercmp_args+=(-a) ;;
        -u|--upgrades)
            mode=upgrades ;;
        -f|--format)
            shift; mode=format; format_str=$1 ;;
        -t|--table)
            mode=table ;;
        -J|--json)
            mode=json ;;
        -F|--attr|--field)
            shift; mode=attr; attr=$1 ;;
        -l|--list)
            mode=list ;;
        --list-attr)
            mode=list_attr ;;
        --list-path|--path-list)
            mode=list_path ;;
        --list-repo|--repo-list)
            mode=list_repo ;;
        --path)
            mode=path ;;
        --status)
            mode=status ;;
        --status-file)
            printf >&2 'deprecation warning: %s --status-file FILE is replaced by aur repo --status >FILE\n' "$argv0"
            shift; status_file=$1
            mode=status ;;
        --dump-options)
            printf -- '--%s\n' "${opt_long[@]}" ${AUR_DEBUG+"${opt_hidden[@]}"}
            printf -- '%s' "${opt_short}" | sed 's/.:\?/-&\n/g'
            exit ;;
        --) shift; break ;;
    esac
    shift
done

# Retrieve local repository configuration
declare -A conf_file_repo conf_sync_repo

while read -r section; do
    server=$(pacconf "${conf_args[@]}" Server --repo="$section" --single)
    prefix=${server%://*}

    if [[ $prefix == "file" ]]; then
        conf_file_repo[$section]=${server#*://}
    else
        conf_sync_repo[$section]=$server
    fi
done < <(pacconf "${conf_args[@]}" --repo-list)
wait $! || exit

# List configured local repositories
if [[ $mode == "list_repo" ]]; then
    printf '%s\n' "${!conf_file_repo[@]}"
    exit 0
elif [[ $mode == "list_path" ]]; then
    printf '%s\n' "${conf_file_repo[@]}"
    exit 0
fi

# Assign environment variables
: "${db_ext=$AUR_DBEXT}" "${db_name=$AUR_REPO}" "${db_root=$AUR_DBROOT}"

# If no repository is specified on the command-line, assume we want a local
# repository and try to disambiguate the name.
if [[ ! $db_name ]]; then
    if (( ${#conf_file_repo[@]} == 1 )); then
        db_name=${!conf_file_repo[*]}

    elif (( ${#conf_file_repo[@]} > 1 )); then
        printf >&2 '%s: repository choice is ambiguous (use -d to specify)\n' "$argv0"

        for repo in "${!conf_file_repo[@]}"; do
            printf '%q\t%q\n' "$repo" "${conf_file_repo[$repo]}"
        done | column -o $'\t' -t >&2
        exit 1
    else
        printf >&2 '%s: no file:// repository configured\n' "$argv0"
        exit 2
    fi

elif [[ $db_query == "local" ]] && [[ ${conf_sync_repo[$db_name]} ]]; then
    printf >&2 '%s: %s: object is remote (use -S to query)\n' "$argv0" "${conf_sync_repo[$db_name]}"
    exit 66
fi

# Default value if -d was specified, but not -r
# XXX: will be empty for remote repository
if [[ ! $db_root ]]; then
    db_root=${conf_file_repo[$db_name]}
fi

# Process local database directly
if [[ $db_query == "local" ]]; then
    db_path=$db_root/$db_name.${db_ext:-db}
    db_path=$(realpath -- "$db_path") # resolve repo-add symlink

# Process copy (pacman --sync) of remote database
elif [[ $db_query == "sync" ]]; then
    pacman_dbpath=$(pacconf "${conf_args[@]}" DBPath) || exit
    db_path=$pacman_dbpath/sync/$db_name.${db_ext:-db}
fi

# Basic checks for database
if [[ ! -f $db_path ]]; then
    printf >&2 '%s: %s: repository path not found\n' "$argv0" "$db_name"
    exit 2
elif [[ $mode == "path" ]]; then
    printf '%s\n' "$db_path"
    exit 0
elif [[ $mode == "status" ]] && [[ -v status_file ]]; then
    printf 'repo:%s\nroot:%s\npath:%s\n' "$db_name" "$db_root" "$db_path" >"$status_file"
    exit 0
elif [[ $mode == "status" ]]; then
    printf 'repo:%s\nroot:%s\npath:%s\n' "$db_name" "$db_root" "$db_path"
    exit 0
fi

# Main operations
set -o pipefail
case $mode in
    list)
        aur repo-parse -p "$db_path" --list | cut -f "$list_cols" ;;
    list_attr)
        aur repo-parse -p "$db_path" --list-attr ;;
    upgrades)
        aur repo-parse -p "$db_path" --list | aur vercmp "${vercmp_args[@]}" ;;
    attr)
        aur repo-parse -p "$db_path" --attr "$attr" ;;
    json)
        aur repo-parse -p "$db_path" --json ;;
    format)
        aur repo-parse -p "$db_path" --json | aur format -f "$format_str" ;;
    table)
        aur repo-parse -p "$db_path" --json | aur format --table ;;
    *)
        printf >&2 'error: %s: no mode specified\n' "$argv0"
        exit 1 ;;
esac

# vim: set et sw=4 sts=4 ft=sh:
